<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Eldon Chung - Project Portfolio</title>
<link rel="stylesheet" href="../stylesheets/gh-pages.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<link rel="stylesheet" href="../stylesheets/coderay-asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Eldon Chung - Project Portfolio</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="project-coinbook"><a class="link" href="#project-coinbook">PROJECT: CoinBook</a></h2>
<div class="sectionbody">
<hr>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="link" href="#overview">Overview</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>CoinBook is a desktop accounting application written in Java. It is targeted at cryptocurrency traders and enthusiasts, and allows them to keep track of the coins they hold, obtain price data and analytics, and read the latest news relevant to them in the same place. Primary interaction is through a CLI, and a GUI built with JavaFX.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary-of-contributions"><a class="link" href="#summary-of-contributions">Summary of contributions</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Major enhancement</strong>: Added <strong>advanced search criteria and boolean logical operators</strong></p>
<div class="ulist">
<ul>
<li>
<p>What it does: Allows the user to search through the <em>CoinBook</em> based on Code, price, etc as well as boolean combinations of these.</p>
</li>
<li>
<p>Justification: This lets users search through a large set of coins quickly as well as allow users the power of very specific queries.
This allows for ease of use and handling of a large Coin base.</p>
</li>
<li>
<p>Highlights: This enhancement involved revamping the entire input sanitation to allow for a higher level of parsing.
The resulting system was then used by enhancements written by other team members. Many alternative design considerations were made and tradeoffs were sacrificed.</p>
</li>
<li>
<p>Credits: Concepts of tokenization, parsing, syntax specification and boolean predicate generation were covered extensively in <em>Compilers: Principles, Techniques, and Tools</em> by Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman.
The conceptualization of the parser would not have been possible without the valuable lessons obtained from that book.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Proposed extensions</strong> :</p>
<div class="ulist">
<ul>
<li>
<p>Boolean logical queries may be difficult for users to consistently express. One possible enhancement could be to include syntax
highlighting on the text as it is typed in to notify the user when the string is valid without requiring the user to use the <code>Enter</code> key.</p>
</li>
<li>
<p>It could be very useful to automatically translate such boolean queries into English as the user types the queries, to give them a sense of
what their expression means. For example: when the user keys in <code>(p/&gt;50 AND t/fav) OR c/BTC</code> it could be possible for some text
to appear with the following sentence: "Based on this query, you wish to find all coins that are priced above 50 dollars and you have tagged as favourite. Also,
you wish to find the coin named BTC".</p>
</li>
<li>
<p>The Tokenizer, along with its TokenTypes and the SyntaxParser was designed to be extensible in the case there needs to be
a drastic change in syntax. An approach to the Unix-style command line interface is another possible direction.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Minor enhancement</strong>: Added a news panel which loads subreddits for coins through the view command when invoked. Also provided the ability for <em>CoinBook</em> to warn
the user when the coin added does not exist.</p>
</li>
<li>
<p><strong>Code contributed</strong>: [<a href="https://github.com/CS2103JAN2018-F09-B3/main/blob/master/collated/functional/Eldon-Chung.md">Functional code</a>] [<a href="https://github.com/CS2103JAN2018-F09-B3/main/blob/master/collated/test/Eldon-Chung.md">Test code</a>]</p>
</li>
<li>
<p><strong>Other contributions</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Project management:</p>
<div class="ulist">
<ul>
<li>
<p>Managed releases <code>v1.5rc</code> (1 release) on GitHub</p>
</li>
</ul>
</div>
</li>
<li>
<p>Enhancements to existing features:</p>
<div class="ulist">
<ul>
<li>
<p>Refactored old tests to suit new code base (Pull requests <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/202">#202</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/202">#211</a>)</p>
</li>
<li>
<p>Refactored entire code base for general quality (<a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/147">#147</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/138">#138</a>,
<a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/112">#112</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/189">#189</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/204">#204</a>)</p>
</li>
<li>
<p>Reported and addressed bugs (Pull requests <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/183">#183</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/issues/184">#184</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/issues/188">#188</a>,
<a href="https://github.com/CS2103JAN2018-F09-B3/main/issues/191">#191</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/issues/192">#192</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/193">#193</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Documentation:</p>
<div class="ulist">
<ul>
<li>
<p>Managed the UG and DG: (Pull requests <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/121">#121</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/180">#180</a>, <a href="https://github.com/CS2103JAN2018-F09-B3/main/pull/76">#76</a>)</p>
</li>
<li>
<p>Standardised the diagram color scheme and renamed "address to coin" in the UG and DG: (Pull requests <a href="https://github.com/CS2103JAN2018-F09-B3/main/commit/01dbe64f74fe4a7a8ce156988d8c25afb0ae64da">1</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Community:</p>
<div class="ulist">
<ul>
<li>
<p>Reported bugs for other teams in the class(examples:  <a href="https://github.com/CS2103JAN2018-F12-B3/main/issues/108#event-1570704377">1</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Tools:</p>
<div class="ulist">
<ul>
<li>
<p>Used PlantUML for generating diagrams for the Developer Guide
== Contributions to the User Guide</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Given below is the main section I contributed to the User Guide. They showcase my ability to write documentation targeting end-users.</em></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="search-through-accounts-code-find-code-code-f-code-code-coming-in-v1-5-code"><a class="link" href="#search-through-accounts-code-find-code-code-f-code-code-coming-in-v1-5-code">Search through accounts <code>find</code> | <code>f</code> <code>[Coming in v1.5]</code></a></h3>
<div class="listingblock">
<div class="title">Format</div>
<div class="content">
<pre>find CONDITION</pre>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><strong>CONDITION</strong></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Must follow the <a href="#find">format</a> listed below</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Updates the listing to show only coin accounts whose details satisfy the given condition.</p>
</div>
<div id="find" class="sidebarblock">
<div class="content">
<div class="title">Condition Query Format</div>
<div class="ulist">
<ul>
<li>
<p>Possible query options are:<br></p>
<div class="ulist">
<ul>
<li>
<p><code>n/NAME</code>:  Name of the coin [Coming in v2.0]</p>
</li>
<li>
<p><code>c/CODE</code>: Trading code of the coin (can be a substring, and is case insensitive)</p>
</li>
<li>
<p><code>t/TAG&#8230;&#8203;</code>: Tags attached to the coin</p>
</li>
<li>
<p><code>p/PRICE</code>: Current price, in dollars, of the coin</p>
</li>
<li>
<p><code>h/AMOUNT</code>: Current amount, in coin units, held in an account</p>
</li>
<li>
<p><code>b/AMOUNT</code>: Total amount, in dollars, ever bought in the account</p>
</li>
<li>
<p><code>s/AMOUNT</code>: Total amount, in dollars, ever sold from the account</p>
</li>
<li>
<p><code>m/MADE</code>: Total profit, in dollars, made from this account so far</p>
</li>
<li>
<p><code>w/WORTH</code>: How much, in dollars, the current amount held is worth at the current price</p>
</li>
</ul>
</div>
</li>
<li>
<p>To specify amounts, put '=', <code>&gt;</code>, or <code>&lt;</code> to specify amounts equal to, greater, or less than; for example:</p>
<div class="ulist">
<ul>
<li>
<p><code>m/=90</code> : Profit made is exactly $90</p>
</li>
<li>
<p><code>p/&gt;500</code>: Current price exceeding $500</p>
</li>
<li>
<p><code>s/&lt;20</code>: Total amount sold less than $20</p>
</li>
</ul>
</div>
</li>
<li>
<p>Possible logical operators include:</p>
<div class="ulist">
<ul>
<li>
<p><code>AND</code>: The conditions on both sides need to be matched</p>
</li>
<li>
<p><code>OR</code>: Only one of the conditions on either side need to be matched</p>
</li>
<li>
<p><code>NOT</code>: Reverses the matching result of the following condition</p>
</li>
<li>
<p><code>(&#160;)</code>: Evaluates conditions inside parentheses first, starting with the innermost one</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="literalblock">
<div class="title">Examples</div>
<div class="content">
<pre>find c/BT</pre>
</div>
</div>
<div class="paragraph">
<p>Finds accounts with <code>BT</code> in their code</p>
</div>
<div class="literalblock">
<div class="content">
<pre>find t/fav</pre>
</div>
</div>
<div class="paragraph">
<p>Finds accounts with the <code>fav</code> tag</p>
</div>
<div class="literalblock">
<div class="content">
<pre>find (p/&gt;500 AND t/fav) OR h/&lt;20</pre>
</div>
</div>
<div class="paragraph">
<p>Finds accounts either with current price more than $500 and tagged <code>fav</code>, or with less than 20 coins left</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributions-to-the-developer-guide"><a class="link" href="#contributions-to-the-developer-guide">Contributions to the Developer Guide</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Given below is the main section I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project.</em></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="condition-parser-component"><a class="link" href="#condition-parser-component">Condition Parser Component</a></h3>
<div class="sect3">
<h4 id="current-implementation"><a class="link" href="#current-implementation">Current implementation</a></h4>
<div class="paragraph">
<p>The general parser for the SQL-like arguments for the find command can be broken down into a few sub-components, namely <code>ArgumentTokenizer</code>, <code>SyntaxParser</code>, <code>SemanticParser</code>, and a <code>ConditionGenerator</code>, while using classes such as <code>Condition</code>,
<code>Token</code>, <code>TokenType</code>, <code>TokenStack</code> to model the data that is to be operated on throughout the process. Their tasks are
delegated as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ArgumentTokenizer</code> : Lexically analyzes the input string, then creates a list of tokens</p>
</li>
<li>
<p><code>SyntaxParser</code> : Parses the input by matching the tokens versus a list of rules to ensure they fit the desired
structure</p>
</li>
<li>
<p><code>SemanticParser</code> : Parses the input by matching the tokens versus a list of rules to ensure their meaning is semantically valid</p>
</li>
<li>
<p><code>ConditionGenerator</code> : Uses the list of tokens to create the equivalent lambda function to evaluate <code>Coin</code> objects against.</p>
</li>
<li>
<p><code>Condition</code> : Serves as a wrapper/container for the boolean lambdas used to evaluate coins for filtering purposes.</p>
</li>
<li>
<p><code>Token</code> : Serves as a container for the sectioned input strings.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The distinction between the Syntax Parser and the Semantic Parser is that the former is oblivious as to what the
input actually means, and only cares whether the structure is correct, whereas the latter verifies the meaning behind the
input.<br>
For example, <code>n/BTC AND OR p/&gt;500</code> is invalid syntatically, whereas <code>n/BTC or p/&gt;BTC</code> is valid syntatically
but not semantically, since it would not make sense to search for <code>Coin</code> objects whose price attribute was more than
"BTC" (prices cannot be compared to names).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following sequence diagram (Fig. 11) will show how input arguments accompanying the <code>find</code> command are parsed:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FindCommandSequence.png" alt="FindCommandSequence">
</div>
<div class="title">Figure 1. Sequence Diagram for Argument Parsing</div>
</div>
<div class="paragraph">
<p>The <code>SyntaxParser</code>, <code>SemanticParser</code> and <code>ConditionGenerator</code> classes reside in a separate module that will be called by the
<code>ParserUtil</code> class during the ParseCondition method.</p>
</div>
<div class="paragraph">
<p>The following activity diagram (Fig. 12) expands on the Parse Sequence block in the previous diagram.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FindActivityDiagram.png" alt="FindActivityDiagram">
</div>
<div class="title">Figure 2. Activity Diagram for Parser Operations</div>
</div>
<div class="paragraph">
<p>The <code>Condition</code> object that is generated at the end is actually just a <code>Predicate</code> object that evaluates properties of
the Coin objects and returns a true/false value.</p>
</div>
</div>
<div class="sect3">
<h4 id="error-handling"><a class="link" href="#error-handling">Error handling</a></h4>
<div class="paragraph">
<p>On syntactically and semantically invalid inputs, <code>ConditionParser</code> will retrieve the expected and actual type of
<code>Token</code> that were not a match during the parsing phase from <code>TokenStack</code> and raise a <code>ParseException</code> before returning.</p>
</div>
<div class="paragraph">
<p>In the event that strings intended to represent tags or numbers are not valid, an <code>IllegalValueException</code> instead,
as per convention from <code>ParserUtil</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations"><a class="link" href="#design-considerations">Design Considerations</a></h4>
<div class="sect4">
<h5 id="aspect-specification-of-syntax"><a class="link" href="#aspect-specification-of-syntax">Aspect: Specification of syntax</a></h5>
<div class="ulist">
<ul>
<li>
<p><strong>Alternative 1 (current choice):</strong> Have the structure of the methods reflect exactly the syntax.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Any subsequent changes can be easily made by having the code reflect the new syntax, since the syntax is apparent.</p>
</li>
<li>
<p>Cons: It is more cumbersome to have to alter the code every time there is a change in syntax.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Alternative 2:</strong> Specify the syntax in a separate file (e.g. EBNF file), and metaprogram the parser based on the file.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: This requires no code change whenever the syntax has to be modified.</p>
</li>
<li>
<p>Cons: The code to support this would be more complicated and not apparent to developers immediately.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aspect-implementation-of-code-syntaxparser-code-code-semanticparser-code-code-conditiongenerator-code"><a class="link" href="#aspect-implementation-of-code-syntaxparser-code-code-semanticparser-code-code-conditiongenerator-code">Aspect: Implementation of <code>SyntaxParser</code>, <code>SemanticParser</code>, <code>ConditionGenerator</code></a></h5>
<div class="ulist">
<ul>
<li>
<p><strong>Alternative 1 (current choice):</strong> Have separate classes that have the same structure but with different return values.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: This approach maintains SRP.</p>
</li>
<li>
<p>Cons: A change in syntax will require changes across 3 classes. It is also very redundant to have similar code.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Alternative 2:</strong> Have a single implementation that performs syntax parsing, semantic parsing and the condition generation.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: There will be less redundant code.</p>
</li>
<li>
<p>Cons: This approach clearly violates SRP.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="advanced-details"><a class="link" href="#advanced-details">Advanced details</a></h4>
<div class="sect4">
<h5 id="argument-tokenizing"><a class="link" href="#argument-tokenizing">Argument Tokenizing</a></h5>
<div class="paragraph">
<p>We will illustrate the flow of tokenizing an example input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>&gt; n/BTC OR ( t/fav AND p/&gt;100 )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Lexer would tokenize this into:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>&gt; [n/,OPTION][BTC,STRING][OR ,BINARYOP][(,LEFTPAREN][t/,OPTION][fav,STRING][AND,BINRARYOP][p/,OPTION][&gt;,COMPARATOR][100,NUMBER][),RIGHTPAREN]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the whitespace has now been discarded, since it is not used for the purposes of parsing. Also each section of
the input (i.e. token) has now been grouped with a type.</p>
</div>
<div class="paragraph">
<p>Below is a sequence diagram (Fig. 13) describing the behaviour of <code>ArgumentTokenizer</code> on the input:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/Lexer.png" alt="Lexer">
</div>
<div class="title">Figure 3. Sequence Diagram for the <code>ArgumentTokenizer</code> Class</div>
</div>
</div>
<div class="sect4">
<h5 id="syntax-parser"><a class="link" href="#syntax-parser">Syntax Parser</a></h5>
<div class="paragraph">
<p>Next, the syntax parser has to ensure that the sequence of tokens is actually structurally valid.
This is done by matching the tokens off based on the following rules, expressed in Backus-Naur form:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>EXPRESSION</code> := <code>TERM</code> | <code>TERM</code> <code>BINARYOP</code> <code>EXPRESSION</code></p>
</li>
<li>
<p><code>TERM</code> := <code>LEFTPAREN</code> <code>EXPRESSION</code> <code>RIGHTPAREN</code> | <code>UNARYOP</code> <code>TERM</code> | <code>CONDITION</code></p>
</li>
<li>
<p><code>CONDITION</code> := <code>OPTION</code> <code>COMPARATOR</code> <code>NUM</code> | <code>OPTION</code> <code>STRING</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>&gt; [n/,OPTION][BTC,STRING][ OR ,BINARYOP][(,LEFTPAREN][t/,OPTION][fav,STRING][AND,BINRARYOP][p/,OPTION][&gt;,COMPARATOR][100,NUMBER][),RIGHTPAREN]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using our example, we will illustrate how we can sequentially express the above tokenized argument based on the provided rules:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><strong>EXPRESSION</strong></code></p>
</li>
<li>
<p><code><strong>TERM</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code></p>
</li>
<li>
<p><code><strong>CONDITION</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code></p>
</li>
<li>
<p><code><strong>OPTION</strong></code> <code><strong>STRING</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code></p>
</li>
<li>
<p><code>n/</code> <code><strong>STRING</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code><strong>EXPRESSION</strong></code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code><strong>TERM</strong></code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code><strong>EXPRESSION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code><strong>TERM</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code><strong>CONDITION</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code><strong>OPTION</strong></code> <code><strong>STRING</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code><strong>STRING</strong></code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code><strong>BINARYOP</strong></code> <code><strong>EXPRESSION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code>AND</code> <code><strong>EXPRESSION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code>AND</code> <code><strong>TERM</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code>AND</code> <code><strong>CONDITION</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code>AND</code> <code><strong>OPTION</strong></code> <code><strong>COMPARATOR</strong></code> <code><strong>NUM</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code>AND</code> <code>p/</code> <code><strong>COMPARATOR</strong></code> <code><strong>NUM</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code>AND</code> <code>p/</code> <code>&gt;</code> <code><strong>NUM</strong></code> <code>)</code></p>
</li>
<li>
<p><code>n/</code> <code>BTC</code> <code>OR</code> <code>(</code> <code>t/</code> <code>fav</code> <code>AND</code> <code>p/</code> <code>&gt;</code> <code>100</code> <code>)</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The recursive methods <code>Expression</code>, <code>Term</code>, <code>Condition</code> in the syntax parser class will match their own respective tokens
as necessary. In fact the method calls in the parser are exactly the same as the matches made in the previously stated sequence.
For example, here is the implementation for <code>EXPRESSION</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> expression() {
    <span class="keyword">if</span> (!term()) {
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
    <span class="keyword">while</span> (tokenStack.matchAndPopTokenType(TokenType.BINARYBOOL)) {
        <span class="keyword">if</span> (!term()) {
            <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        }
    }
    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Visually we can represent sequence of matching with the following parse tree (Fig. 14), which also serves as the recursion tree:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/parsetree.png" alt="parsetree">
</div>
<div class="title">Figure 4. Parse and Recursion Tree for the Example Input</div>
</div>
</div>
<div class="sect4">
<h5 id="semantic-parser"><a class="link" href="#semantic-parser">Semantic Parser</a></h5>
<div class="paragraph">
<p>Following up, the Semantic Parser has to verify that the conditions are correct. This can be done by verifying the
type of the condition versus the parameters that follow. For example, a name condition should only be followed by a string.
This can be done by checking the corresponding option class versus the type of token that follows.</p>
</div>
<div class="paragraph">
<p>Thus, the checks that are made are just to ensure every string type option is followed by a string and every number type
option is followed by a number.</p>
</div>
</div>
<div class="sect4">
<h5 id="condition-generator"><a class="link" href="#condition-generator">Condition Generator</a></h5>
<div class="paragraph">
<p>Lastly, the condition generator creates lambdas based on the type of conditions found, and then recursively composes each
condition based on the binary operators encounters up the recursion tree.</p>
</div>
<div class="paragraph">
<p>The final <code>Condition</code> object is actually just a composition of many individual <code>Condition</code> objects. This can be done
as a back call at the end of each recursion tree.</p>
</div>
<div class="paragraph">
<p>For example, consider the following argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>p/&gt;100 AND t/fav</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>p/&gt;100</code> is a condition on price whereas <code>t/fav</code> is a condition on tags, and they can be composed using the <code>Predicate</code>
method <code>and()</code> to return a logical conjunction of the two conditions.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="project-powerpointlabs"><a class="link" href="#project-powerpointlabs">PROJECT: PowerPointLabs</a></h2>
<div class="sectionbody">
<hr>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-04-15 07:07:37 UTC
</div>
</div>
</body>
</html>